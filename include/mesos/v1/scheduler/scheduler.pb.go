// Code generated by protoc-gen-go.
// source: scheduler.proto
// DO NOT EDIT!

/*
Package mesos_v1_scheduler is a generated protocol buffer package.

It is generated from these files:
	scheduler.proto

It has these top-level messages:
	Event
	Response
	Call
*/
package mesos_v1_scheduler

import proto "github.com/golang/protobuf/proto"
import math "math"
import mesos_v1 "github.com/carlonelong/mesos-framework-sdk/include/mesos/v1"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = math.Inf

// Possible event types, followed by message definitions if
// applicable.
type Event_Type int32

const (
	// This must be the first enum value in this list, to
	// ensure that if 'type' is not set, the default value
	// is UNKNOWN. This enables enum values to be added
	// in a backwards-compatible way. See: MESOS-4997.
	Event_UNKNOWN                 Event_Type = 0
	Event_SUBSCRIBED              Event_Type = 1
	Event_OFFERS                  Event_Type = 2
	Event_INVERSE_OFFERS          Event_Type = 9
	Event_RESCIND                 Event_Type = 3
	Event_RESCIND_INVERSE_OFFER   Event_Type = 10
	Event_UPDATE                  Event_Type = 4
	Event_UPDATE_OPERATION_STATUS Event_Type = 11
	Event_MESSAGE                 Event_Type = 5
	Event_FAILURE                 Event_Type = 6
	Event_ERROR                   Event_Type = 7
	// Periodic message sent by the Mesos master according to
	// 'Subscribed.heartbeat_interval_seconds'. If the scheduler does
	// not receive any events (including heartbeats) for an extended
	// period of time (e.g., 5 x heartbeat_interval_seconds), there is
	// likely a network partition. In such a case the scheduler should
	// close the existing subscription connection and resubscribe
	// using a backoff strategy.
	Event_HEARTBEAT Event_Type = 8
)

var Event_Type_name = map[int32]string{
	0:  "UNKNOWN",
	1:  "SUBSCRIBED",
	2:  "OFFERS",
	9:  "INVERSE_OFFERS",
	3:  "RESCIND",
	10: "RESCIND_INVERSE_OFFER",
	4:  "UPDATE",
	11: "UPDATE_OPERATION_STATUS",
	5:  "MESSAGE",
	6:  "FAILURE",
	7:  "ERROR",
	8:  "HEARTBEAT",
}
var Event_Type_value = map[string]int32{
	"UNKNOWN":                 0,
	"SUBSCRIBED":              1,
	"OFFERS":                  2,
	"INVERSE_OFFERS":          9,
	"RESCIND":                 3,
	"RESCIND_INVERSE_OFFER":   10,
	"UPDATE":                  4,
	"UPDATE_OPERATION_STATUS": 11,
	"MESSAGE":                 5,
	"FAILURE":                 6,
	"ERROR":                   7,
	"HEARTBEAT":               8,
}

func (x Event_Type) Enum() *Event_Type {
	p := new(Event_Type)
	*p = x
	return p
}
func (x Event_Type) String() string {
	return proto.EnumName(Event_Type_name, int32(x))
}
func (x *Event_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Event_Type_value, data, "Event_Type")
	if err != nil {
		return err
	}
	*x = Event_Type(value)
	return nil
}

// Each of the responses of type `FOO` corresponds to `Foo` message below.
type Response_Type int32

const (
	Response_UNKNOWN              Response_Type = 0
	Response_RECONCILE_OPERATIONS Response_Type = 1
)

var Response_Type_name = map[int32]string{
	0: "UNKNOWN",
	1: "RECONCILE_OPERATIONS",
}
var Response_Type_value = map[string]int32{
	"UNKNOWN":              0,
	"RECONCILE_OPERATIONS": 1,
}

func (x Response_Type) Enum() *Response_Type {
	p := new(Response_Type)
	*p = x
	return p
}
func (x Response_Type) String() string {
	return proto.EnumName(Response_Type_name, int32(x))
}
func (x *Response_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Response_Type_value, data, "Response_Type")
	if err != nil {
		return err
	}
	*x = Response_Type(value)
	return nil
}

// Possible call types, followed by message definitions if
// applicable.
type Call_Type int32

const (
	// See comments above on `Event::Type` for more details on this enum value.
	Call_UNKNOWN                      Call_Type = 0
	Call_SUBSCRIBE                    Call_Type = 1
	Call_TEARDOWN                     Call_Type = 2
	Call_ACCEPT                       Call_Type = 3
	Call_DECLINE                      Call_Type = 4
	Call_ACCEPT_INVERSE_OFFERS        Call_Type = 13
	Call_DECLINE_INVERSE_OFFERS       Call_Type = 14
	Call_REVIVE                       Call_Type = 5
	Call_KILL                         Call_Type = 6
	Call_SHUTDOWN                     Call_Type = 7
	Call_ACKNOWLEDGE                  Call_Type = 8
	Call_ACKNOWLEDGE_OPERATION_STATUS Call_Type = 15
	Call_RECONCILE                    Call_Type = 9
	Call_RECONCILE_OPERATIONS         Call_Type = 16
	Call_MESSAGE                      Call_Type = 10
	Call_REQUEST                      Call_Type = 11
	Call_SUPPRESS                     Call_Type = 12
)

var Call_Type_name = map[int32]string{
	0:  "UNKNOWN",
	1:  "SUBSCRIBE",
	2:  "TEARDOWN",
	3:  "ACCEPT",
	4:  "DECLINE",
	13: "ACCEPT_INVERSE_OFFERS",
	14: "DECLINE_INVERSE_OFFERS",
	5:  "REVIVE",
	6:  "KILL",
	7:  "SHUTDOWN",
	8:  "ACKNOWLEDGE",
	15: "ACKNOWLEDGE_OPERATION_STATUS",
	9:  "RECONCILE",
	16: "RECONCILE_OPERATIONS",
	10: "MESSAGE",
	11: "REQUEST",
	12: "SUPPRESS",
}
var Call_Type_value = map[string]int32{
	"UNKNOWN":                      0,
	"SUBSCRIBE":                    1,
	"TEARDOWN":                     2,
	"ACCEPT":                       3,
	"DECLINE":                      4,
	"ACCEPT_INVERSE_OFFERS":        13,
	"DECLINE_INVERSE_OFFERS":       14,
	"REVIVE":                       5,
	"KILL":                         6,
	"SHUTDOWN":                     7,
	"ACKNOWLEDGE":                  8,
	"ACKNOWLEDGE_OPERATION_STATUS": 15,
	"RECONCILE":                    9,
	"RECONCILE_OPERATIONS":         16,
	"MESSAGE":                      10,
	"REQUEST":                      11,
	"SUPPRESS":                     12,
}

func (x Call_Type) Enum() *Call_Type {
	p := new(Call_Type)
	*p = x
	return p
}
func (x Call_Type) String() string {
	return proto.EnumName(Call_Type_name, int32(x))
}
func (x *Call_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Call_Type_value, data, "Call_Type")
	if err != nil {
		return err
	}
	*x = Call_Type(value)
	return nil
}

// *
// Scheduler event API.
//
// An event is described using the standard protocol buffer "union"
// trick, see:
// https://developers.google.com/protocol-buffers/docs/techniques#union.
type Event struct {
	// Type of the event, indicates which optional field below should be
	// present if that type has a nested message definition.
	// Enum fields should be optional, see: MESOS-4997.
	Type                  *Event_Type                  `protobuf:"varint,1,opt,name=type,enum=mesos.v1.scheduler.Event_Type" json:"type,omitempty"`
	Subscribed            *Event_Subscribed            `protobuf:"bytes,2,opt,name=subscribed" json:"subscribed,omitempty"`
	Offers                *Event_Offers                `protobuf:"bytes,3,opt,name=offers" json:"offers,omitempty"`
	InverseOffers         *Event_InverseOffers         `protobuf:"bytes,9,opt,name=inverse_offers" json:"inverse_offers,omitempty"`
	Rescind               *Event_Rescind               `protobuf:"bytes,4,opt,name=rescind" json:"rescind,omitempty"`
	RescindInverseOffer   *Event_RescindInverseOffer   `protobuf:"bytes,10,opt,name=rescind_inverse_offer" json:"rescind_inverse_offer,omitempty"`
	Update                *Event_Update                `protobuf:"bytes,5,opt,name=update" json:"update,omitempty"`
	UpdateOperationStatus *Event_UpdateOperationStatus `protobuf:"bytes,11,opt,name=update_operation_status" json:"update_operation_status,omitempty"`
	Message               *Event_Message               `protobuf:"bytes,6,opt,name=message" json:"message,omitempty"`
	Failure               *Event_Failure               `protobuf:"bytes,7,opt,name=failure" json:"failure,omitempty"`
	Error                 *Event_Error                 `protobuf:"bytes,8,opt,name=error" json:"error,omitempty"`
	XXX_unrecognized      []byte                       `json:"-"`
}

func (m *Event) Reset()         { *m = Event{} }
func (m *Event) String() string { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()    {}

func (m *Event) GetType() Event_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Event_UNKNOWN
}

func (m *Event) GetSubscribed() *Event_Subscribed {
	if m != nil {
		return m.Subscribed
	}
	return nil
}

func (m *Event) GetOffers() *Event_Offers {
	if m != nil {
		return m.Offers
	}
	return nil
}

func (m *Event) GetInverseOffers() *Event_InverseOffers {
	if m != nil {
		return m.InverseOffers
	}
	return nil
}

func (m *Event) GetRescind() *Event_Rescind {
	if m != nil {
		return m.Rescind
	}
	return nil
}

func (m *Event) GetRescindInverseOffer() *Event_RescindInverseOffer {
	if m != nil {
		return m.RescindInverseOffer
	}
	return nil
}

func (m *Event) GetUpdate() *Event_Update {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *Event) GetUpdateOperationStatus() *Event_UpdateOperationStatus {
	if m != nil {
		return m.UpdateOperationStatus
	}
	return nil
}

func (m *Event) GetMessage() *Event_Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *Event) GetFailure() *Event_Failure {
	if m != nil {
		return m.Failure
	}
	return nil
}

func (m *Event) GetError() *Event_Error {
	if m != nil {
		return m.Error
	}
	return nil
}

// First event received when the scheduler subscribes.
type Event_Subscribed struct {
	FrameworkId *mesos_v1.FrameworkID `protobuf:"bytes,1,req,name=framework_id" json:"framework_id,omitempty"`
	// This value will be set if the master is sending heartbeats. See
	// the comment above on 'HEARTBEAT' for more details.
	HeartbeatIntervalSeconds *float64 `protobuf:"fixed64,2,opt,name=heartbeat_interval_seconds" json:"heartbeat_interval_seconds,omitempty"`
	// Since Mesos 1.1.
	MasterInfo       *mesos_v1.MasterInfo `protobuf:"bytes,3,opt,name=master_info" json:"master_info,omitempty"`
	XXX_unrecognized []byte               `json:"-"`
}

func (m *Event_Subscribed) Reset()         { *m = Event_Subscribed{} }
func (m *Event_Subscribed) String() string { return proto.CompactTextString(m) }
func (*Event_Subscribed) ProtoMessage()    {}

func (m *Event_Subscribed) GetFrameworkId() *mesos_v1.FrameworkID {
	if m != nil {
		return m.FrameworkId
	}
	return nil
}

func (m *Event_Subscribed) GetHeartbeatIntervalSeconds() float64 {
	if m != nil && m.HeartbeatIntervalSeconds != nil {
		return *m.HeartbeatIntervalSeconds
	}
	return 0
}

func (m *Event_Subscribed) GetMasterInfo() *mesos_v1.MasterInfo {
	if m != nil {
		return m.MasterInfo
	}
	return nil
}

// Received whenever there are new resources that are offered to the
// scheduler. Each offer corresponds to a set of resources on an
// agent. Until the scheduler accepts or declines an offer the
// resources are considered allocated to the scheduler.
type Event_Offers struct {
	Offers           []*mesos_v1.Offer `protobuf:"bytes,1,rep,name=offers" json:"offers,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *Event_Offers) Reset()         { *m = Event_Offers{} }
func (m *Event_Offers) String() string { return proto.CompactTextString(m) }
func (*Event_Offers) ProtoMessage()    {}

func (m *Event_Offers) GetOffers() []*mesos_v1.Offer {
	if m != nil {
		return m.Offers
	}
	return nil
}

// Received whenever there are resources requested back from the
// scheduler. Each inverse offer specifies the agent, and
// optionally specific resources. Accepting or Declining an inverse
// offer informs the allocator of the scheduler's ability to release
// the specified resources without violating an SLA. If no resources
// are specified then all resources on the agent are requested to be
// released.
type Event_InverseOffers struct {
	InverseOffers    []*mesos_v1.InverseOffer `protobuf:"bytes,1,rep,name=inverse_offers" json:"inverse_offers,omitempty"`
	XXX_unrecognized []byte                   `json:"-"`
}

func (m *Event_InverseOffers) Reset()         { *m = Event_InverseOffers{} }
func (m *Event_InverseOffers) String() string { return proto.CompactTextString(m) }
func (*Event_InverseOffers) ProtoMessage()    {}

func (m *Event_InverseOffers) GetInverseOffers() []*mesos_v1.InverseOffer {
	if m != nil {
		return m.InverseOffers
	}
	return nil
}

// Received when a particular offer is no longer valid (e.g., the
// agent corresponding to the offer has been removed) and hence
// needs to be rescinded. Any future calls ('Accept' / 'Decline') made
// by the scheduler regarding this offer will be invalid.
type Event_Rescind struct {
	OfferId          *mesos_v1.OfferID `protobuf:"bytes,1,req,name=offer_id" json:"offer_id,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *Event_Rescind) Reset()         { *m = Event_Rescind{} }
func (m *Event_Rescind) String() string { return proto.CompactTextString(m) }
func (*Event_Rescind) ProtoMessage()    {}

func (m *Event_Rescind) GetOfferId() *mesos_v1.OfferID {
	if m != nil {
		return m.OfferId
	}
	return nil
}

// Received when a particular inverse offer is no longer valid
// (e.g., the agent corresponding to the offer has been removed)
// and hence needs to be rescinded. Any future calls ('Accept' /
// 'Decline') made by the scheduler regarding this inverse offer
// will be invalid.
type Event_RescindInverseOffer struct {
	InverseOfferId   *mesos_v1.OfferID `protobuf:"bytes,1,req,name=inverse_offer_id" json:"inverse_offer_id,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *Event_RescindInverseOffer) Reset()         { *m = Event_RescindInverseOffer{} }
func (m *Event_RescindInverseOffer) String() string { return proto.CompactTextString(m) }
func (*Event_RescindInverseOffer) ProtoMessage()    {}

func (m *Event_RescindInverseOffer) GetInverseOfferId() *mesos_v1.OfferID {
	if m != nil {
		return m.InverseOfferId
	}
	return nil
}

// Received whenever there is a status update that is generated by
// the executor or agent or master. Status updates should be used by
// executors to reliably communicate the status of the tasks that
// they manage. It is crucial that a terminal update (see TaskState
// in v1/mesos.proto) is sent by the executor as soon as the task
// terminates, in order for Mesos to release the resources allocated
// to the task. It is also the responsibility of the scheduler to
// explicitly acknowledge the receipt of a status update. See
// 'Acknowledge' in the 'Call' section below for the semantics.
//
// A task status update may be used for guaranteed delivery of some
// task-related information, e.g., task's health update. Such
// information may be shadowed by subsequent task status updates, that
// do not preserve fields of the previously sent message.
type Event_Update struct {
	Status           *mesos_v1.TaskStatus `protobuf:"bytes,1,req,name=status" json:"status,omitempty"`
	XXX_unrecognized []byte               `json:"-"`
}

func (m *Event_Update) Reset()         { *m = Event_Update{} }
func (m *Event_Update) String() string { return proto.CompactTextString(m) }
func (*Event_Update) ProtoMessage()    {}

func (m *Event_Update) GetStatus() *mesos_v1.TaskStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// Received when there is an operation status update generated by the
// master, agent, or resource provider. These updates are only sent to
// the framework for operations which had the operation ID set by the
// framework. It is the responsibility of the scheduler to explicitly
// acknowledge the receipt of a status update.
// See 'AcknowledgeOperationStatus' in the 'Call' section below for
// the semantics.
type Event_UpdateOperationStatus struct {
	Status           *mesos_v1.OperationStatus `protobuf:"bytes,1,req,name=status" json:"status,omitempty"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *Event_UpdateOperationStatus) Reset()         { *m = Event_UpdateOperationStatus{} }
func (m *Event_UpdateOperationStatus) String() string { return proto.CompactTextString(m) }
func (*Event_UpdateOperationStatus) ProtoMessage()    {}

func (m *Event_UpdateOperationStatus) GetStatus() *mesos_v1.OperationStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// Received when a custom message generated by the executor is
// forwarded by the master. Note that this message is not
// interpreted by Mesos and is only forwarded (without reliability
// guarantees) to the scheduler. It is up to the executor to retry
// if the message is dropped for any reason.
type Event_Message struct {
	AgentId          *mesos_v1.AgentID    `protobuf:"bytes,1,req,name=agent_id" json:"agent_id,omitempty"`
	ExecutorId       *mesos_v1.ExecutorID `protobuf:"bytes,2,req,name=executor_id" json:"executor_id,omitempty"`
	Data             []byte               `protobuf:"bytes,3,req,name=data" json:"data,omitempty"`
	XXX_unrecognized []byte               `json:"-"`
}

func (m *Event_Message) Reset()         { *m = Event_Message{} }
func (m *Event_Message) String() string { return proto.CompactTextString(m) }
func (*Event_Message) ProtoMessage()    {}

func (m *Event_Message) GetAgentId() *mesos_v1.AgentID {
	if m != nil {
		return m.AgentId
	}
	return nil
}

func (m *Event_Message) GetExecutorId() *mesos_v1.ExecutorID {
	if m != nil {
		return m.ExecutorId
	}
	return nil
}

func (m *Event_Message) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// Received when an agent is removed from the cluster (e.g., failed
// health checks) or when an executor is terminated. Note that, this
// event coincides with receipt of terminal UPDATE events for any
// active tasks belonging to the agent or executor and receipt of
// 'Rescind' events for any outstanding offers belonging to the
// agent. Note that there is no guaranteed order between the
// 'Failure', 'Update' and 'Rescind' events when an agent or executor
// is removed.
// TODO(vinod): Consider splitting the lost agent and terminated
// executor into separate events and ensure it's reliably generated.
type Event_Failure struct {
	AgentId *mesos_v1.AgentID `protobuf:"bytes,1,opt,name=agent_id" json:"agent_id,omitempty"`
	// If this was just a failure of an executor on an agent then
	// 'executor_id' will be set and possibly 'status' (if we were
	// able to determine the exit status).
	ExecutorId *mesos_v1.ExecutorID `protobuf:"bytes,2,opt,name=executor_id" json:"executor_id,omitempty"`
	// On Posix, `status` corresponds to termination information in the
	// `stat_loc` area returned from a `waitpid` call. On Windows, `status`
	// is obtained via calling the `GetExitCodeProcess()` function. For
	// messages coming from Posix agents, schedulers need to apply
	// `WEXITSTATUS` family macros or equivalent transformations to obtain
	// exit codes.
	//
	// TODO(alexr): Consider unifying Windows and Posix behavior by returning
	// exit code here, see MESOS-7241.
	Status           *int32 `protobuf:"varint,3,opt,name=status" json:"status,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Event_Failure) Reset()         { *m = Event_Failure{} }
func (m *Event_Failure) String() string { return proto.CompactTextString(m) }
func (*Event_Failure) ProtoMessage()    {}

func (m *Event_Failure) GetAgentId() *mesos_v1.AgentID {
	if m != nil {
		return m.AgentId
	}
	return nil
}

func (m *Event_Failure) GetExecutorId() *mesos_v1.ExecutorID {
	if m != nil {
		return m.ExecutorId
	}
	return nil
}

func (m *Event_Failure) GetStatus() int32 {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return 0
}

// Received when there is an unrecoverable error in the scheduler (e.g.,
// scheduler failed over, rate limiting, authorization errors etc.). The
// scheduler should abort on receiving this event.
type Event_Error struct {
	Message          *string `protobuf:"bytes,1,req,name=message" json:"message,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Event_Error) Reset()         { *m = Event_Error{} }
func (m *Event_Error) String() string { return proto.CompactTextString(m) }
func (*Event_Error) ProtoMessage()    {}

func (m *Event_Error) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

// *
// Synchronous responses for calls made to the scheduler API.
type Response struct {
	Type                *Response_Type                `protobuf:"varint,1,opt,name=type,enum=mesos.v1.scheduler.Response_Type" json:"type,omitempty"`
	ReconcileOperations *Response_ReconcileOperations `protobuf:"bytes,2,opt,name=reconcile_operations" json:"reconcile_operations,omitempty"`
	XXX_unrecognized    []byte                        `json:"-"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}

func (m *Response) GetType() Response_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Response_UNKNOWN
}

func (m *Response) GetReconcileOperations() *Response_ReconcileOperations {
	if m != nil {
		return m.ReconcileOperations
	}
	return nil
}

type Response_ReconcileOperations struct {
	OperationStatuses []*mesos_v1.OperationStatus `protobuf:"bytes,1,rep,name=operation_statuses" json:"operation_statuses,omitempty"`
	XXX_unrecognized  []byte                      `json:"-"`
}

func (m *Response_ReconcileOperations) Reset()         { *m = Response_ReconcileOperations{} }
func (m *Response_ReconcileOperations) String() string { return proto.CompactTextString(m) }
func (*Response_ReconcileOperations) ProtoMessage()    {}

func (m *Response_ReconcileOperations) GetOperationStatuses() []*mesos_v1.OperationStatus {
	if m != nil {
		return m.OperationStatuses
	}
	return nil
}

// *
// Scheduler call API.
//
// Like Event, a Call is described using the standard protocol buffer
// "union" trick (see above).
type Call struct {
	// Identifies who generated this call. Master assigns a framework id
	// when a new scheduler subscribes for the first time. Once assigned,
	// the scheduler must set the 'framework_id' here and within its
	// FrameworkInfo (in any further 'Subscribe' calls). This allows the
	// master to identify a scheduler correctly across disconnections,
	// failovers, etc.
	FrameworkId *mesos_v1.FrameworkID `protobuf:"bytes,1,opt,name=framework_id" json:"framework_id,omitempty"`
	// Type of the call, indicates which optional field below should be
	// present if that type has a nested message definition.
	// See comments on `Event::Type` above on the reasoning behind this
	// field being optional.
	Type                       *Call_Type                       `protobuf:"varint,2,opt,name=type,enum=mesos.v1.scheduler.Call_Type" json:"type,omitempty"`
	Subscribe                  *Call_Subscribe                  `protobuf:"bytes,3,opt,name=subscribe" json:"subscribe,omitempty"`
	Accept                     *Call_Accept                     `protobuf:"bytes,4,opt,name=accept" json:"accept,omitempty"`
	Decline                    *Call_Decline                    `protobuf:"bytes,5,opt,name=decline" json:"decline,omitempty"`
	AcceptInverseOffers        *Call_AcceptInverseOffers        `protobuf:"bytes,13,opt,name=accept_inverse_offers" json:"accept_inverse_offers,omitempty"`
	DeclineInverseOffers       *Call_DeclineInverseOffers       `protobuf:"bytes,14,opt,name=decline_inverse_offers" json:"decline_inverse_offers,omitempty"`
	Revive                     *Call_Revive                     `protobuf:"bytes,15,opt,name=revive" json:"revive,omitempty"`
	Kill                       *Call_Kill                       `protobuf:"bytes,6,opt,name=kill" json:"kill,omitempty"`
	Shutdown                   *Call_Shutdown                   `protobuf:"bytes,7,opt,name=shutdown" json:"shutdown,omitempty"`
	Acknowledge                *Call_Acknowledge                `protobuf:"bytes,8,opt,name=acknowledge" json:"acknowledge,omitempty"`
	AcknowledgeOperationStatus *Call_AcknowledgeOperationStatus `protobuf:"bytes,17,opt,name=acknowledge_operation_status" json:"acknowledge_operation_status,omitempty"`
	Reconcile                  *Call_Reconcile                  `protobuf:"bytes,9,opt,name=reconcile" json:"reconcile,omitempty"`
	ReconcileOperations        *Call_ReconcileOperations        `protobuf:"bytes,18,opt,name=reconcile_operations" json:"reconcile_operations,omitempty"`
	Message                    *Call_Message                    `protobuf:"bytes,10,opt,name=message" json:"message,omitempty"`
	Request                    *Call_Request                    `protobuf:"bytes,11,opt,name=request" json:"request,omitempty"`
	Suppress                   *Call_Suppress                   `protobuf:"bytes,16,opt,name=suppress" json:"suppress,omitempty"`
	XXX_unrecognized           []byte                           `json:"-"`
}

func (m *Call) Reset()         { *m = Call{} }
func (m *Call) String() string { return proto.CompactTextString(m) }
func (*Call) ProtoMessage()    {}

func (m *Call) GetFrameworkId() *mesos_v1.FrameworkID {
	if m != nil {
		return m.FrameworkId
	}
	return nil
}

func (m *Call) GetType() Call_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Call_UNKNOWN
}

func (m *Call) GetSubscribe() *Call_Subscribe {
	if m != nil {
		return m.Subscribe
	}
	return nil
}

func (m *Call) GetAccept() *Call_Accept {
	if m != nil {
		return m.Accept
	}
	return nil
}

func (m *Call) GetDecline() *Call_Decline {
	if m != nil {
		return m.Decline
	}
	return nil
}

func (m *Call) GetAcceptInverseOffers() *Call_AcceptInverseOffers {
	if m != nil {
		return m.AcceptInverseOffers
	}
	return nil
}

func (m *Call) GetDeclineInverseOffers() *Call_DeclineInverseOffers {
	if m != nil {
		return m.DeclineInverseOffers
	}
	return nil
}

func (m *Call) GetRevive() *Call_Revive {
	if m != nil {
		return m.Revive
	}
	return nil
}

func (m *Call) GetKill() *Call_Kill {
	if m != nil {
		return m.Kill
	}
	return nil
}

func (m *Call) GetShutdown() *Call_Shutdown {
	if m != nil {
		return m.Shutdown
	}
	return nil
}

func (m *Call) GetAcknowledge() *Call_Acknowledge {
	if m != nil {
		return m.Acknowledge
	}
	return nil
}

func (m *Call) GetAcknowledgeOperationStatus() *Call_AcknowledgeOperationStatus {
	if m != nil {
		return m.AcknowledgeOperationStatus
	}
	return nil
}

func (m *Call) GetReconcile() *Call_Reconcile {
	if m != nil {
		return m.Reconcile
	}
	return nil
}

func (m *Call) GetReconcileOperations() *Call_ReconcileOperations {
	if m != nil {
		return m.ReconcileOperations
	}
	return nil
}

func (m *Call) GetMessage() *Call_Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *Call) GetRequest() *Call_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *Call) GetSuppress() *Call_Suppress {
	if m != nil {
		return m.Suppress
	}
	return nil
}

// Subscribes the scheduler with the master to receive events. A
// scheduler must send other calls only after it has received the
// SUBCRIBED event.
type Call_Subscribe struct {
	// See the comments below on 'framework_id' on the semantics for
	// 'framework_info.id'.
	FrameworkInfo *mesos_v1.FrameworkInfo `protobuf:"bytes,1,req,name=framework_info" json:"framework_info,omitempty"`
	// List of suppressed roles for which the framework does not wish to be
	// offered resources. The framework can decide to suppress all or a subset
	// of roles the framework (re)registers as.
	SuppressedRoles  []string `protobuf:"bytes,2,rep,name=suppressed_roles" json:"suppressed_roles,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Call_Subscribe) Reset()         { *m = Call_Subscribe{} }
func (m *Call_Subscribe) String() string { return proto.CompactTextString(m) }
func (*Call_Subscribe) ProtoMessage()    {}

func (m *Call_Subscribe) GetFrameworkInfo() *mesos_v1.FrameworkInfo {
	if m != nil {
		return m.FrameworkInfo
	}
	return nil
}

func (m *Call_Subscribe) GetSuppressedRoles() []string {
	if m != nil {
		return m.SuppressedRoles
	}
	return nil
}

// Accepts an offer, performing the specified operations
// in a sequential manner.
//
// E.g. Launch a task with a newly reserved persistent volume:
//
//   Accept {
//     offer_ids: [ ... ]
//     operations: [
//       { type: RESERVE,
//         reserve: { resources: [ disk(role):2 ] } }
//       { type: CREATE,
//         create: { volumes: [ disk(role):1+persistence ] } }
//       { type: LAUNCH,
//         launch: { task_infos ... disk(role):1;disk(role):1+persistence } }
//     ]
//   }
//
// Note that any of the offer’s resources not used in the 'Accept'
// call (e.g., to launch a task) are considered unused and might be
// reoffered to other frameworks. In other words, the same OfferID
// cannot be used in more than one 'Accept' call.
type Call_Accept struct {
	OfferIds         []*mesos_v1.OfferID         `protobuf:"bytes,1,rep,name=offer_ids" json:"offer_ids,omitempty"`
	Operations       []*mesos_v1.Offer_Operation `protobuf:"bytes,2,rep,name=operations" json:"operations,omitempty"`
	Filters          *mesos_v1.Filters           `protobuf:"bytes,3,opt,name=filters" json:"filters,omitempty"`
	XXX_unrecognized []byte                      `json:"-"`
}

func (m *Call_Accept) Reset()         { *m = Call_Accept{} }
func (m *Call_Accept) String() string { return proto.CompactTextString(m) }
func (*Call_Accept) ProtoMessage()    {}

func (m *Call_Accept) GetOfferIds() []*mesos_v1.OfferID {
	if m != nil {
		return m.OfferIds
	}
	return nil
}

func (m *Call_Accept) GetOperations() []*mesos_v1.Offer_Operation {
	if m != nil {
		return m.Operations
	}
	return nil
}

func (m *Call_Accept) GetFilters() *mesos_v1.Filters {
	if m != nil {
		return m.Filters
	}
	return nil
}

// Declines an offer, signaling the master to potentially reoffer
// the resources to a different framework. Note that this is same
// as sending an Accept call with no operations. See comments on
// top of 'Accept' for semantics.
type Call_Decline struct {
	OfferIds         []*mesos_v1.OfferID `protobuf:"bytes,1,rep,name=offer_ids" json:"offer_ids,omitempty"`
	Filters          *mesos_v1.Filters   `protobuf:"bytes,2,opt,name=filters" json:"filters,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *Call_Decline) Reset()         { *m = Call_Decline{} }
func (m *Call_Decline) String() string { return proto.CompactTextString(m) }
func (*Call_Decline) ProtoMessage()    {}

func (m *Call_Decline) GetOfferIds() []*mesos_v1.OfferID {
	if m != nil {
		return m.OfferIds
	}
	return nil
}

func (m *Call_Decline) GetFilters() *mesos_v1.Filters {
	if m != nil {
		return m.Filters
	}
	return nil
}

// Accepts an inverse offer. Inverse offers should only be accepted
// if the resources in the offer can be safely evacuated before the
// provided unavailability.
type Call_AcceptInverseOffers struct {
	InverseOfferIds  []*mesos_v1.OfferID `protobuf:"bytes,1,rep,name=inverse_offer_ids" json:"inverse_offer_ids,omitempty"`
	Filters          *mesos_v1.Filters   `protobuf:"bytes,2,opt,name=filters" json:"filters,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *Call_AcceptInverseOffers) Reset()         { *m = Call_AcceptInverseOffers{} }
func (m *Call_AcceptInverseOffers) String() string { return proto.CompactTextString(m) }
func (*Call_AcceptInverseOffers) ProtoMessage()    {}

func (m *Call_AcceptInverseOffers) GetInverseOfferIds() []*mesos_v1.OfferID {
	if m != nil {
		return m.InverseOfferIds
	}
	return nil
}

func (m *Call_AcceptInverseOffers) GetFilters() *mesos_v1.Filters {
	if m != nil {
		return m.Filters
	}
	return nil
}

// Declines an inverse offer. Inverse offers should be declined if
// the resources in the offer might not be safely evacuated before
// the provided unavailability.
type Call_DeclineInverseOffers struct {
	InverseOfferIds  []*mesos_v1.OfferID `protobuf:"bytes,1,rep,name=inverse_offer_ids" json:"inverse_offer_ids,omitempty"`
	Filters          *mesos_v1.Filters   `protobuf:"bytes,2,opt,name=filters" json:"filters,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *Call_DeclineInverseOffers) Reset()         { *m = Call_DeclineInverseOffers{} }
func (m *Call_DeclineInverseOffers) String() string { return proto.CompactTextString(m) }
func (*Call_DeclineInverseOffers) ProtoMessage()    {}

func (m *Call_DeclineInverseOffers) GetInverseOfferIds() []*mesos_v1.OfferID {
	if m != nil {
		return m.InverseOfferIds
	}
	return nil
}

func (m *Call_DeclineInverseOffers) GetFilters() *mesos_v1.Filters {
	if m != nil {
		return m.Filters
	}
	return nil
}

// Revive offers for the specified roles. If `roles` is empty,
// the `REVIVE` call will revive offers for all of the roles
// the framework is currently subscribed to.
type Call_Revive struct {
	Roles            []string `protobuf:"bytes,1,rep,name=roles" json:"roles,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Call_Revive) Reset()         { *m = Call_Revive{} }
func (m *Call_Revive) String() string { return proto.CompactTextString(m) }
func (*Call_Revive) ProtoMessage()    {}

func (m *Call_Revive) GetRoles() []string {
	if m != nil {
		return m.Roles
	}
	return nil
}

// Kills a specific task. If the scheduler has a custom executor,
// the kill is forwarded to the executor and it is up to the
// executor to kill the task and send a TASK_KILLED (or TASK_FAILED)
// update. Note that Mesos releases the resources for a task once it
// receives a terminal update (See TaskState in v1/mesos.proto) for
// it. If the task is unknown to the master, a TASK_LOST update is
// generated.
//
// If a task within a task group is killed before the group is
// delivered to the executor, all tasks in the task group are
// killed. When a task group has been delivered to the executor,
// it is up to the executor to decide how to deal with the kill.
// Note The default Mesos executor will currently kill all the
// tasks in the task group if it gets a kill for any task.
type Call_Kill struct {
	TaskId  *mesos_v1.TaskID  `protobuf:"bytes,1,req,name=task_id" json:"task_id,omitempty"`
	AgentId *mesos_v1.AgentID `protobuf:"bytes,2,opt,name=agent_id" json:"agent_id,omitempty"`
	// If set, overrides any previously specified kill policy for this task.
	// This includes 'TaskInfo.kill_policy' and 'Executor.kill.kill_policy'.
	// Can be used to forcefully kill a task which is already being killed.
	KillPolicy       *mesos_v1.KillPolicy `protobuf:"bytes,3,opt,name=kill_policy" json:"kill_policy,omitempty"`
	XXX_unrecognized []byte               `json:"-"`
}

func (m *Call_Kill) Reset()         { *m = Call_Kill{} }
func (m *Call_Kill) String() string { return proto.CompactTextString(m) }
func (*Call_Kill) ProtoMessage()    {}

func (m *Call_Kill) GetTaskId() *mesos_v1.TaskID {
	if m != nil {
		return m.TaskId
	}
	return nil
}

func (m *Call_Kill) GetAgentId() *mesos_v1.AgentID {
	if m != nil {
		return m.AgentId
	}
	return nil
}

func (m *Call_Kill) GetKillPolicy() *mesos_v1.KillPolicy {
	if m != nil {
		return m.KillPolicy
	}
	return nil
}

// Shuts down a custom executor. When the executor gets a shutdown
// event, it is expected to kill all its tasks (and send TASK_KILLED
// updates) and terminate. If the executor doesn’t terminate within
// a certain timeout (configurable via
// '--executor_shutdown_grace_period' agent flag), the agent will
// forcefully destroy the container (executor and its tasks) and
// transition its active tasks to TASK_LOST.
type Call_Shutdown struct {
	ExecutorId       *mesos_v1.ExecutorID `protobuf:"bytes,1,req,name=executor_id" json:"executor_id,omitempty"`
	AgentId          *mesos_v1.AgentID    `protobuf:"bytes,2,req,name=agent_id" json:"agent_id,omitempty"`
	XXX_unrecognized []byte               `json:"-"`
}

func (m *Call_Shutdown) Reset()         { *m = Call_Shutdown{} }
func (m *Call_Shutdown) String() string { return proto.CompactTextString(m) }
func (*Call_Shutdown) ProtoMessage()    {}

func (m *Call_Shutdown) GetExecutorId() *mesos_v1.ExecutorID {
	if m != nil {
		return m.ExecutorId
	}
	return nil
}

func (m *Call_Shutdown) GetAgentId() *mesos_v1.AgentID {
	if m != nil {
		return m.AgentId
	}
	return nil
}

// Acknowledges the receipt of status update. Schedulers are
// responsible for explicitly acknowledging the receipt of status
// updates that have 'Update.status().uuid()' field set. Such status
// updates are retried by the agent until they are acknowledged by
// the scheduler.
type Call_Acknowledge struct {
	AgentId          *mesos_v1.AgentID `protobuf:"bytes,1,req,name=agent_id" json:"agent_id,omitempty"`
	TaskId           *mesos_v1.TaskID  `protobuf:"bytes,2,req,name=task_id" json:"task_id,omitempty"`
	Uuid             []byte            `protobuf:"bytes,3,req,name=uuid" json:"uuid,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *Call_Acknowledge) Reset()         { *m = Call_Acknowledge{} }
func (m *Call_Acknowledge) String() string { return proto.CompactTextString(m) }
func (*Call_Acknowledge) ProtoMessage()    {}

func (m *Call_Acknowledge) GetAgentId() *mesos_v1.AgentID {
	if m != nil {
		return m.AgentId
	}
	return nil
}

func (m *Call_Acknowledge) GetTaskId() *mesos_v1.TaskID {
	if m != nil {
		return m.TaskId
	}
	return nil
}

func (m *Call_Acknowledge) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

// Acknowledges the receipt of an operation status update. Schedulers
// are responsible for explicitly acknowledging the receipt of updates
// which have the 'UpdateOperationStatus.status().uuid()' field set.
// Such status updates are retried by the agent or resource provider
// until they are acknowledged by the scheduler.
type Call_AcknowledgeOperationStatus struct {
	// If the operation affects resources that belong to a SLRP, both
	// `agent_id` and `resource_provider_id` have to be set.
	//
	// If the operation affects resources that belong to a SERP, only
	// `resource_provider_id` has to be set.
	AgentId            *mesos_v1.AgentID            `protobuf:"bytes,1,opt,name=agent_id" json:"agent_id,omitempty"`
	ResourceProviderId *mesos_v1.ResourceProviderID `protobuf:"bytes,2,opt,name=resource_provider_id" json:"resource_provider_id,omitempty"`
	Uuid               []byte                       `protobuf:"bytes,3,req,name=uuid" json:"uuid,omitempty"`
	OperationId        *mesos_v1.OperationID        `protobuf:"bytes,4,req,name=operation_id" json:"operation_id,omitempty"`
	XXX_unrecognized   []byte                       `json:"-"`
}

func (m *Call_AcknowledgeOperationStatus) Reset()         { *m = Call_AcknowledgeOperationStatus{} }
func (m *Call_AcknowledgeOperationStatus) String() string { return proto.CompactTextString(m) }
func (*Call_AcknowledgeOperationStatus) ProtoMessage()    {}

func (m *Call_AcknowledgeOperationStatus) GetAgentId() *mesos_v1.AgentID {
	if m != nil {
		return m.AgentId
	}
	return nil
}

func (m *Call_AcknowledgeOperationStatus) GetResourceProviderId() *mesos_v1.ResourceProviderID {
	if m != nil {
		return m.ResourceProviderId
	}
	return nil
}

func (m *Call_AcknowledgeOperationStatus) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *Call_AcknowledgeOperationStatus) GetOperationId() *mesos_v1.OperationID {
	if m != nil {
		return m.OperationId
	}
	return nil
}

// Allows the scheduler to query the status for non-terminal tasks.
// This causes the master to send back the latest task status for
// each task in 'tasks', if possible. Tasks that are no longer known
// will result in a TASK_LOST, TASK_UNKNOWN, or TASK_UNREACHABLE update.
// If 'tasks' is empty, then the master will send the latest status
// for each task currently known.
type Call_Reconcile struct {
	Tasks            []*Call_Reconcile_Task `protobuf:"bytes,1,rep,name=tasks" json:"tasks,omitempty"`
	XXX_unrecognized []byte                 `json:"-"`
}

func (m *Call_Reconcile) Reset()         { *m = Call_Reconcile{} }
func (m *Call_Reconcile) String() string { return proto.CompactTextString(m) }
func (*Call_Reconcile) ProtoMessage()    {}

func (m *Call_Reconcile) GetTasks() []*Call_Reconcile_Task {
	if m != nil {
		return m.Tasks
	}
	return nil
}

// TODO(vinod): Support arbitrary queries than just state of tasks.
type Call_Reconcile_Task struct {
	TaskId           *mesos_v1.TaskID  `protobuf:"bytes,1,req,name=task_id" json:"task_id,omitempty"`
	AgentId          *mesos_v1.AgentID `protobuf:"bytes,2,opt,name=agent_id" json:"agent_id,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *Call_Reconcile_Task) Reset()         { *m = Call_Reconcile_Task{} }
func (m *Call_Reconcile_Task) String() string { return proto.CompactTextString(m) }
func (*Call_Reconcile_Task) ProtoMessage()    {}

func (m *Call_Reconcile_Task) GetTaskId() *mesos_v1.TaskID {
	if m != nil {
		return m.TaskId
	}
	return nil
}

func (m *Call_Reconcile_Task) GetAgentId() *mesos_v1.AgentID {
	if m != nil {
		return m.AgentId
	}
	return nil
}

// Allows the scheduler to query the status of operations. This causes
// the master to send back the latest status for each operation in
// 'operations', if possible. If 'operations' is empty, then the
// master will send the latest status for each operation currently
// known.
type Call_ReconcileOperations struct {
	Operations       []*Call_ReconcileOperations_Operation `protobuf:"bytes,1,rep,name=operations" json:"operations,omitempty"`
	XXX_unrecognized []byte                                `json:"-"`
}

func (m *Call_ReconcileOperations) Reset()         { *m = Call_ReconcileOperations{} }
func (m *Call_ReconcileOperations) String() string { return proto.CompactTextString(m) }
func (*Call_ReconcileOperations) ProtoMessage()    {}

func (m *Call_ReconcileOperations) GetOperations() []*Call_ReconcileOperations_Operation {
	if m != nil {
		return m.Operations
	}
	return nil
}

type Call_ReconcileOperations_Operation struct {
	OperationId        *mesos_v1.OperationID        `protobuf:"bytes,1,req,name=operation_id" json:"operation_id,omitempty"`
	AgentId            *mesos_v1.AgentID            `protobuf:"bytes,2,opt,name=agent_id" json:"agent_id,omitempty"`
	ResourceProviderId *mesos_v1.ResourceProviderID `protobuf:"bytes,3,opt,name=resource_provider_id" json:"resource_provider_id,omitempty"`
	XXX_unrecognized   []byte                       `json:"-"`
}

func (m *Call_ReconcileOperations_Operation) Reset()         { *m = Call_ReconcileOperations_Operation{} }
func (m *Call_ReconcileOperations_Operation) String() string { return proto.CompactTextString(m) }
func (*Call_ReconcileOperations_Operation) ProtoMessage()    {}

func (m *Call_ReconcileOperations_Operation) GetOperationId() *mesos_v1.OperationID {
	if m != nil {
		return m.OperationId
	}
	return nil
}

func (m *Call_ReconcileOperations_Operation) GetAgentId() *mesos_v1.AgentID {
	if m != nil {
		return m.AgentId
	}
	return nil
}

func (m *Call_ReconcileOperations_Operation) GetResourceProviderId() *mesos_v1.ResourceProviderID {
	if m != nil {
		return m.ResourceProviderId
	}
	return nil
}

// Sends arbitrary binary data to the executor. Note that Mesos
// neither interprets this data nor makes any guarantees about the
// delivery of this message to the executor.
type Call_Message struct {
	AgentId          *mesos_v1.AgentID    `protobuf:"bytes,1,req,name=agent_id" json:"agent_id,omitempty"`
	ExecutorId       *mesos_v1.ExecutorID `protobuf:"bytes,2,req,name=executor_id" json:"executor_id,omitempty"`
	Data             []byte               `protobuf:"bytes,3,req,name=data" json:"data,omitempty"`
	XXX_unrecognized []byte               `json:"-"`
}

func (m *Call_Message) Reset()         { *m = Call_Message{} }
func (m *Call_Message) String() string { return proto.CompactTextString(m) }
func (*Call_Message) ProtoMessage()    {}

func (m *Call_Message) GetAgentId() *mesos_v1.AgentID {
	if m != nil {
		return m.AgentId
	}
	return nil
}

func (m *Call_Message) GetExecutorId() *mesos_v1.ExecutorID {
	if m != nil {
		return m.ExecutorId
	}
	return nil
}

func (m *Call_Message) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// Requests a specific set of resources from Mesos's allocator. If
// the allocator has support for this, corresponding offers will be
// sent asynchronously via the OFFERS event(s).
//
// NOTE: The built-in hierarchical allocator doesn't have support
// for this call and hence simply ignores it.
type Call_Request struct {
	Requests         []*mesos_v1.Request `protobuf:"bytes,1,rep,name=requests" json:"requests,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *Call_Request) Reset()         { *m = Call_Request{} }
func (m *Call_Request) String() string { return proto.CompactTextString(m) }
func (*Call_Request) ProtoMessage()    {}

func (m *Call_Request) GetRequests() []*mesos_v1.Request {
	if m != nil {
		return m.Requests
	}
	return nil
}

// Suppress offers for the specified roles. If `roles` is empty,
// the `SUPPRESS` call will suppress offers for all of the roles
// the framework is currently subscribed to.
type Call_Suppress struct {
	Roles            []string `protobuf:"bytes,1,rep,name=roles" json:"roles,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Call_Suppress) Reset()         { *m = Call_Suppress{} }
func (m *Call_Suppress) String() string { return proto.CompactTextString(m) }
func (*Call_Suppress) ProtoMessage()    {}

func (m *Call_Suppress) GetRoles() []string {
	if m != nil {
		return m.Roles
	}
	return nil
}

func init() {
	proto.RegisterEnum("mesos.v1.scheduler.Event_Type", Event_Type_name, Event_Type_value)
	proto.RegisterEnum("mesos.v1.scheduler.Response_Type", Response_Type_name, Response_Type_value)
	proto.RegisterEnum("mesos.v1.scheduler.Call_Type", Call_Type_name, Call_Type_value)
}
